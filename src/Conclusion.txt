Имеется система уравнений:
x1 + x2 = 2,
x1 + 1.0001x2 = 2.0001 + delta.

Выразим x1 через x2 в первом уравнении, подставим во второе и выразим x2. Итого получится x2 = (2.0001 - 2 + delta) / (1.0001 - 1). Теперь, зная x2, выразим x1 из первого уравнения: x1 = 2 - (2.0001 - 2 + delta) / (1.0001 - 1). 

Попробуем запустить программу, используя эти формулы для нахождения значений и тип данных float. Вычислить момент, когда отклонение решения (отклонение текущего решения от решений изначальной системы с delta = 0) станет не больше 10^(-6), не удалось, так как программа ушла в бесконечный цикл.
Теперь попробуем использовать эти же формулы, но тип данных double. Ответы: 
x1 is 0.9999995231606214, x2 is 1.0000004768393786, delta is 0.0000000000476837
Deviation from the original decision is 0.0000006743526910.

Можно заметить, что вычисление значений можно оптимизировать. Тогда формулы примут вид:
x2 = (0.0001 + delta) / 0.0001,
x1 = 2 - (0.0001 + delta) / 0.0001.
Запустим программу с формулами в таком виде и типом данных float. Ответы:
x1 is 0.9999995231628418, x2 is 1.0000004768371582, delta is 0.0000000000476837
Deviation from the original decision is 0.0000006743495646.
А при использовании типа данных double результаты таковы:
x1 is 0.9999995231628418, x2 is 1.0000004768371582, delta is 0.0000000000476837
Deviation from the original decision is 0.0000006743495762.

Таким образом, эксперимент с использованием типа данных float и без оптимизаций нельзя назвать корректным, так как ответ получить не удалось. При использовании же вычислительной оптимизации эксперимент с float уже можно назвать корректным, так как ответ сходится с остальными с погрешностью 10^(-11). А данный эксперимент с использованием типа данных double корректен и с оптимизациями, и без.
